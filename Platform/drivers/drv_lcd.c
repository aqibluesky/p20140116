/****************************************************************************
 * bsp/drivers/drv_lcd.c
 *
 *   Copyright (C) 2014  DRPM Development Team. All rights reserved.
 *   Author: TSAO, CHIA-CHENG <chiacheng.tsao@gmail.com>
 *
 *   GENERAL DESCRIPTION
 *      This is a driver for the 1.8" SPI display.
 *
 ****************************************************************************/
#include "drv_lcd.h"
#include "drv_spi.h"

#if ( CFG_DRV_LCD > 0 )
#ifdef CODE_1
/* Standard includes. */
#include <stdlib.h>
#include <string.h>

void lcd7735_invertDisplay(const uint8_t mode);
void lcd7735_setRotation(uint8_t m);
void lcd7735_xmit(const uint8_t tb);
void lcd7735_sendCmd(const uint8_t c);
void lcd7735_sendData(const uint8_t d);
static void _putch(uint8_t c);

#define DELAY 0x80
#define putpix(c) { lcd7735_xmit(c >> 8); lcd7735_xmit(c & 0xFF); }
#define _scr(r,c) ((char *)(_screen.scr + ((r) * _screen.ncol) + (c)))

#define cursor_draw		cursor_expose(1)
#define cursor_erase	cursor_expose(0)

static uint16_t _width = ST7735_TFTWIDTH;
static uint16_t _height = ST7735_TFTHEIGHT;

/*
    Font Size           : 8x12
    Memory usage   : 1144 bytes
    Characters        : 95
*/
const unsigned char SmallFont[] = {
0x08,0x0C,0x20,0x5F,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // <Space>
0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00,0x00, // !
0x00,0x28,0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "
0x00,0x00,0x28,0x28,0xFC,0x28,0x50,0xFC,0x50,0x50,0x00,0x00, // #
0x00,0x20,0x78,0xA8,0xA0,0x60,0x30,0x28,0xA8,0xF0,0x20,0x00, // $
0x00,0x00,0x48,0xA8,0xB0,0x50,0x28,0x34,0x54,0x48,0x00,0x00, // %
0x00,0x00,0x20,0x50,0x50,0x78,0xA8,0xA8,0x90,0x6C,0x00,0x00, // &
0x00,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
0x00,0x04,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x04,0x00, // (
0x00,0x40,0x20,0x10,0x10,0x10,0x10,0x10,0x10,0x20,0x40,0x00, // )
0x00,0x00,0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00,0x00,0x00, // *
0x00,0x00,0x20,0x20,0x20,0xF8,0x20,0x20,0x20,0x00,0x00,0x00, // +
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x80, // ,
0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00, // -
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00, // .
0x00,0x08,0x10,0x10,0x10,0x20,0x20,0x40,0x40,0x40,0x80,0x00, // /
0x00,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00, // 0
0x00,0x00,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x00, // 1
0x00,0x00,0x70,0x88,0x88,0x10,0x20,0x40,0x80,0xF8,0x00,0x00, // 2
0x00,0x00,0x70,0x88,0x08,0x30,0x08,0x08,0x88,0x70,0x00,0x00, // 3
0x00,0x00,0x10,0x30,0x50,0x50,0x90,0x78,0x10,0x18,0x00,0x00, // 4
0x00,0x00,0xF8,0x80,0x80,0xF0,0x08,0x08,0x88,0x70,0x00,0x00, // 5
0x00,0x00,0x70,0x90,0x80,0xF0,0x88,0x88,0x88,0x70,0x00,0x00, // 6
0x00,0x00,0xF8,0x90,0x10,0x20,0x20,0x20,0x20,0x20,0x00,0x00, // 7
0x00,0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x88,0x70,0x00,0x00, // 8
0x00,0x00,0x70,0x88,0x88,0x88,0x78,0x08,0x48,0x70,0x00,0x00, // 9
0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x20,0x00,0x00, // :
0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x20,0x00, // ;
0x00,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x00,0x00, // <
0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0x00,0x00, // =
0x00,0x40,0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x40,0x00,0x00, // >
0x00,0x00,0x70,0x88,0x88,0x10,0x20,0x20,0x00,0x20,0x00,0x00, // ?
0x00,0x00,0x70,0x88,0x98,0xA8,0xA8,0xB8,0x80,0x78,0x00,0x00, // @
0x00,0x00,0x20,0x20,0x30,0x50,0x50,0x78,0x48,0xCC,0x00,0x00, // A
0x00,0x00,0xF0,0x48,0x48,0x70,0x48,0x48,0x48,0xF0,0x00,0x00, // B
0x00,0x00,0x78,0x88,0x80,0x80,0x80,0x80,0x88,0x70,0x00,0x00, // C
0x00,0x00,0xF0,0x48,0x48,0x48,0x48,0x48,0x48,0xF0,0x00,0x00, // D
0x00,0x00,0xF8,0x48,0x50,0x70,0x50,0x40,0x48,0xF8,0x00,0x00, // E
0x00,0x00,0xF8,0x48,0x50,0x70,0x50,0x40,0x40,0xE0,0x00,0x00, // F
0x00,0x00,0x38,0x48,0x80,0x80,0x9C,0x88,0x48,0x30,0x00,0x00, // G
0x00,0x00,0xCC,0x48,0x48,0x78,0x48,0x48,0x48,0xCC,0x00,0x00, // H
0x00,0x00,0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0xF8,0x00,0x00, // I
0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x90,0xE0,0x00, // J
0x00,0x00,0xEC,0x48,0x50,0x60,0x50,0x50,0x48,0xEC,0x00,0x00, // K
0x00,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0x44,0xFC,0x00,0x00, // L
0x00,0x00,0xD8,0xD8,0xD8,0xD8,0xA8,0xA8,0xA8,0xA8,0x00,0x00, // M
0x00,0x00,0xDC,0x48,0x68,0x68,0x58,0x58,0x48,0xE8,0x00,0x00, // N
0x00,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00, // O
0x00,0x00,0xF0,0x48,0x48,0x70,0x40,0x40,0x40,0xE0,0x00,0x00, // P
0x00,0x00,0x70,0x88,0x88,0x88,0x88,0xE8,0x98,0x70,0x18,0x00, // Q
0x00,0x00,0xF0,0x48,0x48,0x70,0x50,0x48,0x48,0xEC,0x00,0x00, // R
0x00,0x00,0x78,0x88,0x80,0x60,0x10,0x08,0x88,0xF0,0x00,0x00, // S
0x00,0x00,0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x00, // T
0x00,0x00,0xCC,0x48,0x48,0x48,0x48,0x48,0x48,0x30,0x00,0x00, // U
0x00,0x00,0xCC,0x48,0x48,0x50,0x50,0x30,0x20,0x20,0x00,0x00, // V
0x00,0x00,0xA8,0xA8,0xA8,0x70,0x50,0x50,0x50,0x50,0x00,0x00, // W
0x00,0x00,0xD8,0x50,0x50,0x20,0x20,0x50,0x50,0xD8,0x00,0x00, // X
0x00,0x00,0xD8,0x50,0x50,0x20,0x20,0x20,0x20,0x70,0x00,0x00, // Y
0x00,0x00,0xF8,0x90,0x10,0x20,0x20,0x40,0x48,0xF8,0x00,0x00, // Z
0x00,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x38,0x00, // [
0x00,0x40,0x40,0x40,0x20,0x20,0x10,0x10,0x10,0x08,0x00,0x00, // <Backslash>
0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x70,0x00, // ]
0x00,0x20,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC, // _
0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
0x00,0x00,0x00,0x00,0x00,0x30,0x48,0x38,0x48,0x3C,0x00,0x00, // a
0x00,0x00,0xC0,0x40,0x40,0x70,0x48,0x48,0x48,0x70,0x00,0x00, // b
0x00,0x00,0x00,0x00,0x00,0x38,0x48,0x40,0x40,0x38,0x00,0x00, // c
0x00,0x00,0x18,0x08,0x08,0x38,0x48,0x48,0x48,0x3C,0x00,0x00, // d
0x00,0x00,0x00,0x00,0x00,0x30,0x48,0x78,0x40,0x38,0x00,0x00, // e
0x00,0x00,0x1C,0x20,0x20,0x78,0x20,0x20,0x20,0x78,0x00,0x00, // f
0x00,0x00,0x00,0x00,0x00,0x3C,0x48,0x30,0x40,0x78,0x44,0x38, // g
0x00,0x00,0xC0,0x40,0x40,0x70,0x48,0x48,0x48,0xEC,0x00,0x00, // h
0x00,0x00,0x20,0x00,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00, // i
0x00,0x00,0x10,0x00,0x00,0x30,0x10,0x10,0x10,0x10,0x10,0xE0, // j
0x00,0x00,0xC0,0x40,0x40,0x5C,0x50,0x70,0x48,0xEC,0x00,0x00, // k
0x00,0x00,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0xF8,0x00,0x00, // l
0x00,0x00,0x00,0x00,0x00,0xF0,0xA8,0xA8,0xA8,0xA8,0x00,0x00, // m
0x00,0x00,0x00,0x00,0x00,0xF0,0x48,0x48,0x48,0xEC,0x00,0x00, // n
0x00,0x00,0x00,0x00,0x00,0x30,0x48,0x48,0x48,0x30,0x00,0x00, // o
0x00,0x00,0x00,0x00,0x00,0xF0,0x48,0x48,0x48,0x70,0x40,0xE0, // p
0x00,0x00,0x00,0x00,0x00,0x38,0x48,0x48,0x48,0x38,0x08,0x1C, // q
0x00,0x00,0x00,0x00,0x00,0xD8,0x60,0x40,0x40,0xE0,0x00,0x00, // r
0x00,0x00,0x00,0x00,0x00,0x78,0x40,0x30,0x08,0x78,0x00,0x00, // s
0x00,0x00,0x00,0x20,0x20,0x70,0x20,0x20,0x20,0x18,0x00,0x00, // t
0x00,0x00,0x00,0x00,0x00,0xD8,0x48,0x48,0x48,0x3C,0x00,0x00, // u
0x00,0x00,0x00,0x00,0x00,0xEC,0x48,0x50,0x30,0x20,0x00,0x00, // v
0x00,0x00,0x00,0x00,0x00,0xA8,0xA8,0x70,0x50,0x50,0x00,0x00, // w
0x00,0x00,0x00,0x00,0x00,0xD8,0x50,0x20,0x50,0xD8,0x00,0x00, // x
0x00,0x00,0x00,0x00,0x00,0xEC,0x48,0x50,0x30,0x20,0x20,0xC0, // y
0x00,0x00,0x00,0x00,0x00,0x78,0x10,0x20,0x20,0x78,0x00,0x00, // z
0x00,0x18,0x10,0x10,0x10,0x20,0x10,0x10,0x10,0x10,0x18,0x00, // {
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // |
0x00,0x60,0x20,0x20,0x20,0x10,0x20,0x20,0x20,0x20,0x60,0x00, // }
0x40,0xA4,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ~
};  

// Init for 7735R, part 1 (red or green tab)
static const uint8_t  Rcmd1[] = {                 
	15,							// 15 commands in list:
	ST7735_SWRESET,   DELAY,	//  1: Software reset, 0 args, w/delay
	150,						//     150 ms delay
	ST7735_SLPOUT ,   DELAY,	//  2: Out of sleep mode, 0 args, w/delay
	255,						//     500 ms delay
	ST7735_FRMCTR1, 3      ,	//  3: Frame rate ctrl - normal mode, 3 args:
	0x01, 0x2C, 0x2D,			//     Rate = fosc/(1x2+40) * (LINE+2C+2D)
	ST7735_FRMCTR2, 3      ,	//  4: Frame rate control - idle mode, 3 args:
	0x01, 0x2C, 0x2D,			//     Rate = fosc/(1x2+40) * (LINE+2C+2D)
	ST7735_FRMCTR3, 6      ,	//  5: Frame rate ctrl - partial mode, 6 args:
	0x01, 0x2C, 0x2D,			//     Dot inversion mode
	0x01, 0x2C, 0x2D,			//     Line inversion mode
	ST7735_INVCTR , 1      ,	//  6: Display inversion ctrl, 1 arg, no delay:
	0x07,						//     No inversion
	ST7735_PWCTR1 , 3      ,	//  7: Power control, 3 args, no delay:
	0xA2,
	0x02,						//     -4.6V
	0x84,						//     AUTO mode
	ST7735_PWCTR2 , 1      ,	//  8: Power control, 1 arg, no delay:
	0xC5,						//     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
	ST7735_PWCTR3 , 2      ,	//  9: Power control, 2 args, no delay:
	0x0A,						//     Opamp current small
	0x00,						//     Boost frequency
	ST7735_PWCTR4 , 2      ,	// 10: Power control, 2 args, no delay:
	0x8A,						//     BCLK/2, Opamp current small & Medium low
	0x2A,  
	ST7735_PWCTR5 , 2      ,	// 11: Power control, 2 args, no delay:
	0x8A, 0xEE,
	ST7735_VMCTR1 , 1      ,	// 12: Power control, 1 arg, no delay:
	0x0E,
	ST7735_INVOFF , 0      ,	// 13: Don't invert display, no args, no delay
	ST7735_MADCTL , 1      ,	// 14: Memory access control (directions), 1 arg:
	0xC0,						//     row addr/col addr, bottom to top refresh, RGB order
	ST7735_COLMOD , 1+DELAY,	//  15: Set color mode, 1 arg + delay:
	0x05,						//     16-bit color 5-6-5 color format
	10							//     10 ms delay
};
// Init for 7735R, part 2 (green tab only)
static const uint8_t Rcmd2green[] = {
	2,							//  2 commands in list:
	ST7735_CASET  , 4      ,	//  1: Column addr set, 4 args, no delay:
	0x00, 0x02,					//     XSTART = 0
	0x00, 0x7F+0x02,			//     XEND = 129
	ST7735_RASET  , 4      ,	//  2: Row addr set, 4 args, no delay:
	0x00, 0x01,					//     XSTART = 0
	0x00, 0x9F+0x01				//     XEND = 160
};
// Init for 7735R, part 2 (red tab only)
static const uint8_t Rcmd2red[] = {
	2,							//  2 commands in list:
	ST7735_CASET  , 4      ,	//  1: Column addr set, 4 args, no delay:
	0x00, 0x00,					//     XSTART = 0
	0x00, 0x7F,					//     XEND = 127
	ST7735_RASET  , 4      ,	//  2: Row addr set, 4 args, no delay:
	0x00, 0x00,					//     XSTART = 0
	0x00, 0x9F				//     XEND = 159
};
// Init for 7735R, part 3 (red or green tab)
static const uint8_t Rcmd3[] = {
	4,							//  4 commands in list:
	ST7735_GMCTRP1, 16      ,	//  1: Magical unicorn dust, 16 args, no delay:
	0x02, 0x1c, 0x07, 0x12,
	0x37, 0x32, 0x29, 0x2d,
	0x29, 0x25, 0x2B, 0x39,
	0x00, 0x01, 0x03, 0x10,
	ST7735_GMCTRN1, 16      ,	//  2: Sparkles and rainbows, 16 args, no delay:
	0x03, 0x1d, 0x07, 0x06,
	0x2E, 0x2C, 0x29, 0x2D,
	0x2E, 0x2E, 0x37, 0x3F,
	0x00, 0x00, 0x02, 0x10,
	ST7735_NORON  ,    DELAY,	//  3: Normal display on, no args, w/delay
	10,							//     10 ms delay
	ST7735_DISPON ,    DELAY,	//  4: Main screen turn on, no args w/delay
	100							//     100 ms delay
};

static int colstart = 0;
static int rowstart = 0; // May be overridden in init func
//static uint8_t tabcolor	= 0;
static uint8_t orientation = PORTRAIT;

/* ASCII green-screen terminal emulator */

typedef struct _cursor {
	uint16_t	row;
	uint16_t	col;
	uint8_t		*bitmap; // not used yet
} Cursor;

typedef struct _font {
	uint8_t 	*font;
	uint8_t 	x_size;
	uint8_t 	y_size;
	uint8_t		offset;
	uint16_t	numchars;
} Font;

static struct __screen {
	Cursor 		c;
	uint8_t 	nrow;
	uint8_t 	ncol;
	Font 		fnt;
	uint16_t 	fg;
	uint16_t 	bg;
	char		*scr;
} _screen;

//static Font cfont;
//static uint8_t _transparent = 0;
//static uint16_t _fg = ST7735_GREEN;
//static uint16_t _bg = ST7735_BLACK;


/* printf in "CLib" will call putchar.
   user can implement this function -- send a char to UART? */
int putchar (int c)
{
    lcd7735_putc(c);
    
	return c;
}

void delay_ms(uint32_t ms)
{    
    #if 1 // Use this will save 20 word in code.
    uint32_t c = ms*50; // 49 ~= 1 us / ((1 / 49152000) * 10^6) us

    do{
        //asm("NOP");
        reset_watch_dog();
    }while(--c);
    #else
    unsigned long c = 0;

    for(c = 0 ; c < ( 50*n ) ; c++ )
    {
        asm("NOP");
    }
    #endif
    
}

// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
static void commandList(const uint8_t *addr) {
	uint8_t  numCommands, numArgs;
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
	while(numCommands--) {                 // For each command...
		lcd7735_sendCmd(*addr++); //   Read, issue command
		numArgs  = *addr++;    //   Number of args to follow
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
		while(numArgs--) {                   //   For each argument...
			lcd7735_sendData(*addr++);  //     Read, issue argument
		}

		if(ms) {
			ms = *addr++; // Read post-command delay time (ms)
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
			delay_ms(ms);
		}
	}
}

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
	// toggle RST low to reset; CS low so it'll listen to us
	LCD_CS_L();
#ifdef LCD_SOFT_RESET
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST_H();
	delay_ms(500);
	LCD_RST_L();
	delay_ms(500);
	LCD_RST_H();
	delay_ms(500);
#endif    
	if(cmdList) commandList(cmdList);
}

// Initialization for ST7735R screens (green or red tabs)
void lcd7735_initR(uint8_t options) {
	delay_ms(50);
	commonInit(Rcmd1);
	if(options == INITR_GREENTAB) {
		commandList(Rcmd2green);
		colstart = 2;
		rowstart = 1;
	} else {
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
	}
	commandList(Rcmd3);

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
		lcd7735_sendCmd(ST7735_MADCTL);
		lcd7735_sendData(0xC0);
	}

	//  tabcolor = options;
}

void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(x0+colstart);     // XSTART 
	lcd7735_sendData(0x00);
	lcd7735_sendData(x1+colstart);     // XEND

	lcd7735_sendCmd(ST7735_RASET); // Row addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(y0+rowstart);     // YSTART
	lcd7735_sendData(0x00);
	lcd7735_sendData(y1+rowstart);     // YEND

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
}

void lcd7735_pushColor(uint16_t color) {
	LCD_A0_H();  
	putpix(color);
}

// draw color pixel on screen
void lcd7735_drawPixel(int16_t x, int16_t y, uint16_t color) {

	if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;

	lcd7735_setAddrWindow(x,y,x+1,y+1);
	lcd7735_pushColor(color);
}

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
	if((x + w - 1) >= _width)  w = _width  - x;
	if((y + h - 1) >= _height) h = _height - y;

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);

	LCD_A0_H();
	for(y=h; y>0; y--) {
		for(x=w; x>0; x--) {
			putpix(color);
		}
	}
}

/* Private functions */
static void _scrollup() {
	int r,c;
	_screen.c.row = 0;
	_screen.c.col = 0;
	for(r=1;r<_screen.nrow;r++)
		for(c=0;c<_screen.ncol;c++) {
			_putch(*_scr(r,c));
			_screen.c.col++;
			if( _screen.c.col == _screen.ncol ) {			
				_screen.c.col = 0;
				_screen.c.row++;
			}
		}
		for(c=0;c<_screen.ncol;c++) {
			_putch(' ');
			_screen.c.col++;
		}
		_screen.c.row = _screen.nrow - 1;
		_screen.c.col = 0;
}

static void cursor_expose(int flg) {
	uint8_t i,fz;
	uint16_t j;
	int x,y;

	fz = _screen.fnt.x_size/8;
	x = _screen.c.col * _screen.fnt.x_size;
	y = _screen.c.row * _screen.fnt.y_size;
	lcd7735_setAddrWindow(x,y,x+_screen.fnt.x_size-1,y+_screen.fnt.y_size-1);
	for(j=0;j<((fz)*_screen.fnt.y_size);j++) {
		for(i=0;i<8;i++) {
			if( flg )
				lcd7735_pushColor(_screen.fg);
			else
				lcd7735_pushColor(_screen.bg);
		}
	}
}

static void cursor_nl() {
	_screen.c.col = 0;
	_screen.c.row++;
	if( _screen.c.row == _screen.nrow ) {
		_scrollup();
	}
}

static void cursor_fwd() {
	_screen.c.col++; 
	if( _screen.c.col == _screen.ncol ) {
		cursor_nl();
	}
}


static void cursor_init() {
	_screen.c.row = 0;
	_screen.c.col = 0;
}

static void _putch(uint8_t c) {
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int x,y;

	fz = _screen.fnt.x_size/8;
	x = _screen.c.col * _screen.fnt.x_size;
	y = _screen.c.row * _screen.fnt.y_size;
	lcd7735_setAddrWindow(x,y,x+_screen.fnt.x_size-1,y+_screen.fnt.y_size-1);
	temp=((c-_screen.fnt.offset)*((fz)*_screen.fnt.y_size))+4;
	for(j=0;j<((fz)*_screen.fnt.y_size);j++) {
		ch = _screen.fnt.font[temp];
		for(i=0;i<8;i++) {   
			if((ch&(1<<(7-i)))!=0) {
				lcd7735_pushColor(_screen.fg);
			} else {
				lcd7735_pushColor(_screen.bg);
			}   
		}
		temp++;
	}
	*_scr(_screen.c.row, _screen.c.col) = c;
}

/* Public functions */
void lcd7735_init_screen(void *font,uint16_t fg, uint16_t bg, uint8_t orientation) {
	lcd7735_setRotation(orientation);
	lcd7735_fillScreen(bg);
	_screen.fg = fg;
	_screen.bg = bg;
	_screen.fnt.font = (uint8_t *)font;
	_screen.fnt.x_size = _screen.fnt.font[0];
	_screen.fnt.y_size = _screen.fnt.font[1];
	_screen.fnt.offset = _screen.fnt.font[2];
	_screen.fnt.numchars = _screen.fnt.font[3];
	_screen.nrow = _height / _screen.fnt.y_size;
	_screen.ncol = _width  / _screen.fnt.x_size;
	_screen.scr = malloc(_screen.nrow * _screen.ncol);
	memset((void*)_screen.scr,' ',_screen.nrow * _screen.ncol);
	cursor_init();
	cursor_draw;
}

void lcd7735_putc(char c) {
	if( c != '\n' && c != '\r' ) {
		_putch(c);
		cursor_fwd();
	} else {
		cursor_erase;
		cursor_nl();
	}
	cursor_draw;
}

void lcd7735_puts(char *s) {
	int i;
	for(i=0;i<strlen(s);i++) {
		if( s[i] != '\n' && s[i] != '\r' ) {
			_putch(s[i]);
			cursor_fwd();
		} else {
			cursor_erase;
			cursor_nl();
		}
	}
	cursor_draw;
}

void lcd7735_cursor_set(uint16_t row, uint16_t col) {
	if( row < _screen.nrow && col < _screen.ncol ) {
		_screen.c.row = row;
		_screen.c.col = col;
	}
	cursor_draw;
}

/* Service functions */
void lcd7735_fillScreen(uint16_t color) {
	lcd7735_fillRect(0, 0,  _width, _height, color);
}

// Pass 8-bit (each) R,G,B, get back 16-bit packed color
uint16_t lcd7735_Color565(uint8_t r, uint8_t g, uint8_t b) {
	return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

void lcd7735_setRotation(uint8_t m) {
	uint8_t rotation = m % 4; // can't be higher than 3

	lcd7735_sendCmd(ST7735_MADCTL);
	switch (rotation) {
   case PORTRAIT:
	   lcd7735_sendData(MADCTL_MX | MADCTL_MY | MADCTL_RGB);
	   _width  = ST7735_TFTWIDTH;
	   _height = ST7735_TFTHEIGHT;
	   break;
   case LANDSAPE:
	   lcd7735_sendData(MADCTL_MY | MADCTL_MV | MADCTL_RGB);
	   _width  = ST7735_TFTHEIGHT;
	   _height = ST7735_TFTWIDTH;
	   break;
   case PORTRAIT_FLIP:
	   lcd7735_sendData(MADCTL_RGB);
	   _width  = ST7735_TFTWIDTH;
	   _height = ST7735_TFTHEIGHT;
	   break;
   case LANDSAPE_FLIP:
	   lcd7735_sendData(MADCTL_MX | MADCTL_MV | MADCTL_RGB);
	   _width  = ST7735_TFTHEIGHT;
	   _height = ST7735_TFTWIDTH;
	   break;
   default:
	   return;
	}
	orientation = m;
}

void lcd7735_invertDisplay(const uint8_t mode) {
	if( mode == INVERT_ON ) lcd7735_sendCmd(ST7735_INVON);
	else if( mode == INVERT_OFF ) lcd7735_sendCmd(ST7735_INVOFF);
}

void lcd7735_lcdOff() {
	lcd7735_sendCmd(ST7735_DISPOFF);
}

void lcd7735_lcdOn() {
	lcd7735_sendCmd(ST7735_DISPON);
}

uint8_t lcd7735_getWidth() {
	return(_width);
}
uint8_t lcd7735_getHeight() {
	return(_height);
}

void lcd7735_init(void) {
    spi_initialize();
    LCD_SCK_INIT();
    LCD_SDA_INIT();
    LCD_A0_INIT();
    LCD_RST_INIT();
}

void lcd7735_xmit(const uint8_t tb) {
#if 0
    for(i=0; i<8; i++) {
        if (d & 0x80) LCD_MOSI1;
        else LCD_MOSI0;
        d = d<<1;
        LCD_SCK0;
        LCD_SCK1;
    }
#else
    reset_watch_dog();
	if (tb & 0x80) LCD_SDA_H(); else LCD_SDA_L();	/* bit7 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x40) LCD_SDA_H(); else LCD_SDA_L();	/* bit6 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x20) LCD_SDA_H(); else LCD_SDA_L();	/* bit5 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x10) LCD_SDA_H(); else LCD_SDA_L();	/* bit4 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x08) LCD_SDA_H(); else LCD_SDA_L();	/* bit3 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x04) LCD_SDA_H(); else LCD_SDA_L();	/* bit2 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x02) LCD_SDA_H(); else LCD_SDA_L();	/* bit1 */
	LCD_SCK_L(); LCD_SCK_H();
	if (tb & 0x01) LCD_SDA_H(); else LCD_SDA_L();	/* bit0 */
	LCD_SCK_L(); LCD_SCK_H();
#endif
}

// Send control command to controller
void lcd7735_sendCmd(const uint8_t c) {
    LCD_A0_L();
    //LCD_CS_L();
    lcd7735_xmit(c);
    //LCD_CS_H();
}

// Send parameters o command to controller
void lcd7735_sendData(const uint8_t d) {
    LCD_A0_H();
    //LCD_CS_L();
    lcd7735_xmit(d);
    //LCD_CS_H();
}
#endif

#ifdef CODE_2
#include "limits.h"

// Standard ASCII 5x7 font
static const unsigned char font[] = {
/*	Chars 0-31
       0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
*/	
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,

/*	Chars 128-255	
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
	*/
};

int16_t  cursor_x, cursor_y;
uint16_t textcolor, textbgcolor;
uint8_t  wrap; // If set, 'wrap' text at right edge of display


/*
 * myDelay value must be known at compile time,
 * so here's a dirty hack to circumvent this
 */
void myDelay(uint16_t ms) {
    for(int x=0 ; x < ms ; x+=5) {
        _delay_ms(5);
    }
}


/********************** START SPI STUFF *********************************/



#ifdef SPI_SOFTWARE

/* SPI Software implementation */ 
inline void SPI_begin(void) {

	SPIREG |= (1 << SCK);//out
	SPIREG |= (1 << MOSI);//out

	SPIPORT &= ~(1 << SCK);//lo
	SPIPORT |= (1 << MOSI); //hi - image flickers if MOSI stays low in between transmissions

	DDRB |= (1 << PB2);//out  SS
	PORTB |= (1 << PB2);//hi  SS	
}

inline void SPI_end(void) {
}

/*
inline void spiwrite(uint8_t c) {
	uint8_t i;
	uint8_t mask1=SPIPORT & ~( (1<<SCK) | (1<<MOSI) );
	uint8_t mask2=mask1 | (1<<MOSI);
	
	// Assumed state before call: SCK- Low, MOSI- High 
	for (i=0; i<8 ;i++)
	{
		if (!(c&0x80)) SPIPORT = mask1;  // set data low
		
		SPIPORT |=  (1<< SCK); // SCK hi , data sampled here
		SPIPORT = mask2;       // SCK low, MOSI hi
		c<<=1;						
	}
	// State after call: SCK Low, MOSI high 
}
*/

void spiwrite(uint8_t c) {
	uint8_t i;
	uint8_t mask1=SPIPORT & ~( (1<<SCK) | (1<<MOSI) );
	uint8_t mask2=mask1 | (1<<MOSI);

	// Assumed state before call: SCK- Low, MOSI- High

		asm volatile(

		"		sbrs	%0,7	\n\t"		// 1 bit7
		"		out		%1,%2	\n\t"		// 2
		"		sbi		%1,%4	\n\t"		// 4
		"		out		%1,%3	\n\t"		// 5

		"		sbrs	%0,6	\n\t"		// bit6
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,5	\n\t"		// bit5
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,4	\n\t"		// bit4
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,3	\n\t"		// bit3
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,2	\n\t"		// bit2
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,1	\n\t"		// bit1
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		"		sbrs	%0,0	\n\t"		// bit0
		"		out		%1,%2	\n\t"
		"		sbi		%1,%4	\n\t"
		"		out		%1,%3	\n\t"
		:	
		:	"r" (c), "I" (_SFR_IO_ADDR(SPIPORT)), "r" (mask1), "r" (mask2), "I" (SCK)
		);

	// State after call: SCK Low, MOSI high
}


/* SPI general support functions */

inline void writecommand(uint8_t c) {
	RSPORT &= ~(1 << RS);
	spiwrite(c);
}

inline void writedata(uint8_t c) {
	RSPORT |= (1 << RS);
	spiwrite(c);
}

inline void spistreampixel(uint16_t color) {
	spiwrite(color>>8);
	spiwrite(color&0xff);
}


/* SPI Hardware implementation */

#endif

#ifdef SPI_HARDWARE

inline void SPI_begin(void) {

	uint8_t tmp;
    SPIREG |= (1 << SCK);//out
    SPIREG |= (1 << MOSI);//out
    
    SPIPORT &= ~(1 << SCK);//lo
    SPIPORT &= ~(1 << MOSI);//lo

    DDRB |= (1 << PB2);//out  SS
    PORTB |= (1 << PB2);//hi  SS

	tmp=SPCR;		// Move SPCR to temp register to allow better optimization (saves 16 bytes!)
    tmp |= (1 << MSTR) | (1 << SPE);
	tmp &= ~(1 << DORD);	// Set bit order MSB first
	tmp = (tmp & ~SPI_CLOCK_MASK) | (SPI_CLOCK_DIV2);
	tmp = (tmp & ~SPI_MODE_MASK) | SPI_MODE0;	
	SPCR=tmp;

	SPSR |= 1<<SPI2X;		
}

inline void SPI_end(void) {
    SPCR &= ~(1 << SPE);
}

inline void spiwrite(uint8_t c) {
    SPDR = c;
    while (!(SPSR & (1 << SPIF))) ;
}

/* SPI general support functions */

inline void writecommand(uint8_t c) {
    RSPORT &= ~(1 << RS);
    spiwrite(c);
}

inline void writedata(uint8_t c) {
    RSPORT |= (1 << RS);
    spiwrite(c);
}

inline void spistreampixel(uint16_t color) {
	spiwrite(color>>8);
	spiwrite(color&0xff);
}

#endif

/********************** END SPI STUFF *********************************/

// Rather than a bazillion writecommand() and writedata() calls, screen
// initialization commands and arguments are organized in these tables
// stored in PROGMEM.  The table may look bulky, but that's mostly the
// formatting -- storage-wise this is hundreds of bytes more compact
// than the equivalent code.  Companion function follows.
#define DELAY 0x80
const uint8_t InitCmd[] = {                 // Init for 7735R, part 1 (red or green tab)
    21,                       // 15 commands in list:
    ST7735_SWRESET,   DELAY,  //  1: Software reset, 0 args, w/delay
    150,                    //     150 ms delay
    ST7735_SLPOUT ,   DELAY,  //  2: Out of sleep mode, 0 args, w/delay
    255,                    //     500 ms delay
    ST7735_FRMCTR1, 3      ,  //  3: Frame rate ctrl - normal mode, 3 args:
    0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
    ST7735_FRMCTR2, 3      ,  //  4: Frame rate control - idle mode, 3 args:
    0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
    ST7735_FRMCTR3, 6      ,  //  5: Frame rate ctrl - partial mode, 6 args:
    0x01, 0x2C, 0x2D,       //     Dot inversion mode
    0x01, 0x2C, 0x2D,       //     Line inversion mode
    ST7735_INVCTR , 1      ,  //  6: Display inversion ctrl, 1 arg, no delay:
    0x07,                   //     No inversion
    ST7735_PWCTR1 , 3      ,  //  7: Power control, 3 args, no delay:
    0xA2,
    0x02,                   //     -4.6V
    0x84,                   //     AUTO mode
    ST7735_PWCTR2 , 1      ,  //  8: Power control, 1 arg, no delay:
    0xC5,                   //     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
    ST7735_PWCTR3 , 2      ,  //  9: Power control, 2 args, no delay:
    0x0A,                   //     Opamp current small
    0x00,                   //     Boost frequency
    ST7735_PWCTR4 , 2      ,  // 10: Power control, 2 args, no delay:
    0x8A,                   //     BCLK/2, Opamp current small & Medium low
    0x2A,
    ST7735_PWCTR5 , 2      ,  // 11: Power control, 2 args, no delay:
    0x8A, 0xEE,
    ST7735_VMCTR1 , 1      ,  // 12: Power control, 1 arg, no delay:
    0x0E,
    ST7735_INVOFF , 0      ,  // 13: Don't invert display, no args, no delay
    ST7735_MADCTL , 1      ,  // 14: Memory access control (directions), 1 arg:
    0xC8,                   //     row addr/col addr, bottom to top refresh
    ST7735_COLMOD , 1      ,  // 15: set color mode, 1 arg, no delay:
    0x05,
    ST7735_CASET  , 4      ,  //  1: Column addr set, 4 args, no delay:
    0x00, 0x00,             //     XSTART = 0
    0x00, 0x7F,             //     XEND = 127
    ST7735_RASET  , 4      ,  //  2: Row addr set, 4 args, no delay:
    0x00, 0x00,             //     XSTART = 0
    0x00, 0x9F,
    ST7735_GMCTRP1, 16      , //  1: Magical unicorn dust, 16 args, no delay:
    0x02, 0x1c, 0x07, 0x12,
    0x37, 0x32, 0x29, 0x2d,
    0x29, 0x25, 0x2B, 0x39,
    0x00, 0x01, 0x03, 0x10,
    ST7735_GMCTRN1, 16      , //  2: Sparkles and rainbows, 16 args, no delay:
    0x03, 0x1d, 0x07, 0x06,
    0x2E, 0x2C, 0x29, 0x2D,
    0x2E, 0x2E, 0x37, 0x3F,
    0x00, 0x00, 0x02, 0x10,
    ST7735_NORON  ,    DELAY, //  3: Normal display on, no args, w/delay
    10,                     //     10 ms delay
    ST7735_DISPON ,    DELAY, //  4: Main screen turn on, no args w/delay
    100
};                  //     100 ms delay



// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
static void commandList(const uint8_t *addr) {
	uint8_t  numCommands, numArgs;
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
	while(numCommands--) {                 // For each command...
		lcd7735_sendCmd(*addr++); //   Read, issue command
		numArgs  = *addr++;    //   Number of args to follow
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
		while(numArgs--) {                   //   For each argument...
			lcd7735_sendData(*addr++);  //     Read, issue argument
		}

		if(ms) {
			ms = *addr++; // Read post-command delay time (ms)
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
			delay_ms(ms);
		}
	}
}

void init(void) {
 
    RSREG |= (1 << RS); //out
    RSTREG |= (1 << RST);//out

    SPI_begin();

    RSTPORT |= (1 << RST);
    myDelay(500);
    RSTPORT &= ~(1 << RST);
    myDelay(500);
    RSTPORT |= (1 << RST);
    myDelay(500);

    commandList(InitCmd);

    cursor_y = cursor_x = 0;
    textcolor =  0xFFFF;
	textbgcolor = 0x0000;
    wrap = 1;
}


void setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    writecommand(ST7735_CASET); // Column addr set
    writedata(0x00);
    writedata(x0);     // XSTART
    writedata(0x00);
    writedata(x1);     // XEND

    writecommand(ST7735_RASET); // Row addr set
    writedata(0x00);
    writedata(y0);     // YSTART
    writedata(0x00);
    writedata(y1);     // YEND

    writecommand(ST7735_RAMWR); // write to RAM
}


void fillScreen(uint16_t color) {
	fillRect(0, 0, _width, _height,color);
}


void drawPixel(int16_t x, int16_t y, uint16_t color) {
    if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;

    setAddrWindow(x,y,x+1,y+1);

    RSPORT |= (1 << RS);
	spistreampixel(color);
}


void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    // Rudimentary clipping
    if((x >= _width) || (y >= _height)) return;
    if((y+h-1) >= _height) h = _height-y;
    setAddrWindow(x, y, x, y+h-1);

    RSPORT |= (1 << RS);

    while (h--) {
		spistreampixel(color);
    }
}

void drawFastHLine(int16_t x, int16_t y, int16_t w,
                   uint16_t color) {

    // Rudimentary clipping
    if((x >= _width) || (y >= _height)) return;
    if((x+w-1) >= _width)  w = _width-x;
    setAddrWindow(x, y, x+w-1, y);
 
    RSPORT |= (1 << RS);

    while (w--) {
		spistreampixel(color);
    }
}

// draw a rectangle
void drawRect(int16_t x, int16_t y,
int16_t w, int16_t h,
uint16_t color) {
	drawFastHLine(x, y, w, color);
	drawFastHLine(x, y+h-1, w, color);
	drawFastVLine(x, y, h, color);
	drawFastVLine(x+w-1, y, h, color);
}

// fill a rectangle
void fillRect(int16_t x, int16_t y, int16_t w, int16_t h,uint16_t color) {
    // rudimentary clipping (drawChar w/big text requires this)
    if((x >= _width) || (y >= _height)) return;
    if((x + w - 1) >= _width)  w = _width  - x;
    if((y + h - 1) >= _height) h = _height - y;

    setAddrWindow(x, y, x+w-1, y+h-1);

    RSPORT |= (1 << RS);

    for(y=h; y>0; y--) {
        for(x=w; x>0; x--) {
			spistreampixel(color);
        }
    }
}

void invertDisplay(unsigned char i) {
    writecommand(i ? ST7735_INVON : ST7735_INVOFF);
}

#define swap(a, b) { int16_t t = a; a = b; b = t; }

// bresenham's algorithm - thx wikpedia
void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1) {
		swap(x0, x1);
		swap(y0, y1);
	}

	int16_t dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);

	int16_t err = dx / 2;
	int16_t ystep;

	if (y0 < y1) {
		ystep = 1;
		} else {
		ystep = -1;
	}

	for (; x0<=x1; x0++) {
		if (steep) {
			drawPixel(y0, x0, color);
			} else {
			drawPixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}


void write(uint8_t c) {
	if (c == '\n') {
		cursor_y += 8;
		cursor_x = 0;
		} else if (c == '\r') {
		// skip em
		} else {
		drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor);
		cursor_x += 6;
		if (wrap && (cursor_x > (_width - 6))) {
			cursor_y += 8;
			cursor_x = 0;
		}
	}
}

void print(const char str[]) {
	int x=0;
	while(str[x]) {
		write(str[x]);
		x++;
	}
}

// draw a character
void drawChar(int16_t x, int16_t y, unsigned char c,
uint16_t color, uint16_t bg) {

	if((x >= _width)   || // Clip right
	(y >= _height)     || // Clip bottom
	((x + 5 - 1) < 0)  || // Clip left
	((y + 8 - 1) < 0))    // Clip top
	return;

	c=c-32;
	for (int8_t i=0; i<6; i++ ) {
		uint8_t line;
		if ((i == 5) || (c>(128-32)))   // All invalid characters will print as a space
			line = 0x0;
		else
			line = pgm_read_byte(font+(c*5)+i);

	    setAddrWindow(x+i, y, x+i, y+7);
	    RSPORT |= (1 << RS);

		for (int8_t j = 0; j<8; j++) {
			if (line & 0x1) {
				    spiwrite(color>>8);
					spiwrite(color&0xff);
				} else {
				    spiwrite(bg>>8);
				    spiwrite(bg&0xff);
			}
			line >>= 1; 
		}
	}
}

void setCursor(int16_t x, int16_t y) {
	cursor_x = x;
	cursor_y = y;
}

void setTextColor(uint16_t c, uint16_t b) {
	textcolor = c;
	textbgcolor = b;
}

void setTextWrap(uint8_t w) {
	wrap = w;
}

#endif

#if 0
#ifdef CODE_1
void test_ascii_screen(void) {
	unsigned char x;
	int i;

    //lcd7735_init_screen((void *)&SmallFont[0],ST7735_WHITE,ST7735_BLACK,PORTRAIT);
    x = 0x20;

	for(i=0;i<95;i++) {
		lcd7735_putc(x+i);
	}
}
#endif

#ifdef CODE_2
void myDelay(int16_t ms);

int st7735_lcd_test(void){
	// init the 1.8 lcd display
	init();
	while(1){
		// COLORS AND 'T'
		fillScreen(Color565(0,0,0));
		fillRect(0,0,127,50,Color565(255,0,0));
		setTextColor(Color565(255,255,255),Color565(255,00,00));
		setCursor(55,20);
		print("red");
		fillRect(0,50,127,100,Color565(0,255,0));
		setTextColor(Color565(255,255,255),Color565(0,255,00));
		setCursor(50,70);
		print("green");
		fillRect(0,100,127,159,Color565(0,0,255));
		setTextColor(Color565(255,255,255),Color565(0,00,255));
		setCursor(55,120);
		print("blue");

		drawRect(5,5,118,150,Color565(255,255,255));

		myDelay(5000);
 
		fillScreen(Color565(0,0,0));

		for (uint8_t y=0; y<160; y+=8)
		{
			drawLine(0, 0, 127, y, Color565(255,0,0));	
			drawLine(0, 159, 127, y, Color565(0,255,0));
			drawLine(127, 0, 0, y, Color565(0,0,255));
			drawLine(127, 159, 0, y, Color565(255,255,255));
		}
		myDelay(5000);

		// TEXT		
		fillScreen(Color565(0,0,0));
		setCursor(0,0);
		setTextWrap(1);

		setTextColor(Color565(255,255,255),Color565(0,0,255));
		print("All available chars:\n\n");
		setTextColor(Color565(200,200,255),Color565(50,50,50));
		unsigned char i;
		char ff[]="a";
		for (i=32; i<128; i++) 
		{
			ff[0]=i;
			print(ff);
		}
		myDelay(5000); 
	}

	return 0;
}

#endif
#endif

#endif
